package com.bread.coalquality.mvc.controller.redis;

/**
 * @Description: redis
 * @Author: haoxd
 * @Version: 1.0
 *
 *  备注 -》{
 *     1- redis的命令不区分大小写 ，但是key 是区分大小写
 *     2- 帮助命令 help @String
 *  }
 * <>redis 基本数据类型
 *  1，string:点赞 incr
 *  2，hash ： Map<String,Map<Object,Object>>  ,购物车实现
 *  3，list :点赞，抽奖，共同关注的人
 *  4，set:点赞，抽奖，共同关注的人
 *  5，zset
 *  其他
 *  bitmap 位图
 *  hyperloglogs   统计
 *  GEO 地理
 *  stream
 *
 *
 *  <> redis 6.0 新特性
 *
 *    Redis 官方在2020 5 月份正式推出了 6.0 版本，这个版本中有很多的新特性。所以，6.0 刚刚推出，就受到了业界的广泛关注。
 *
 *
 *   Redis 6.0 中的几个关键新特性，分别是
 *
 *
 *   1 面向网络处理的多 IO 线程->{
 *
 *          1 在 Redis 6.0 中，非常受关注的第一个新特性就是多线程。
 *                  这是因为，Redis 一直被大家熟知的就是它的单线程架构，
 *                  虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF 重写），
 *             但是，从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的。
 *          2 Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。
 *          3 主线程和 IO 线程具体是怎么协作完成请求处理的->{
 *
 *                  阶段一：服务端和客户端建立 Socket 连接，并分配处理线程
 *                      首先，主线程负责接收建立连接请求。当有客户端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，
 *                      并把 Socket 放入全局等待队列中。
 *                      紧接着，主线程通过轮询方法把 Socket 连接分配给 IO 线程。
 *
 *                  阶段二：IO 线程读取并解析请求
 *                         主线程一旦把 Socket 分配给 IO 线程，就会进入阻塞状态，等待 IO 线程完成客户端请求读取和解析。
 *                         因为有多个 IO 线程在并行处理，所以，这个过程很快就可以完成。
 *
 *                  阶段三：主线程执行请求操作
 *                          等到 IO 线程解析完请求，主线程还是会以单线程的方式执行这些命令操作。
 *
 *                  阶段四：IO 线程回写 Socket 和主线程清空全局队列
 *
 *                          当主线程执行完请求操作后，会把需要返回的结果写入缓冲区，
 *                          然后，主线程会阻塞等待 IO 线程把这些结果回写到 Socket 中，并返回给客户端。
 *                          和 IO 线程读取和解析请求一样，IO 线程回写 Socket 时，也是有多个线程在并发执行，所以回写 Socket 的速度也很快。
 *                          等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。
 *
 *
 *
 *          }
 *          4 如何开启redis6.0的多线程 -》{
 *
 *                  在 Redis 6.0 中，多线程机制默认是关闭的，如果需要使用多线程功能，需要在 redis.conf 中完成两个设
 *                  1  设置 io-thread-do-reads 配置项为 yes，表示启用多线程。
 *                  2 设置线程个数。一般来说，线程个数要小于 Redis 实例所在机器的 CPU 核个数，
 *                      例如，对于一个 8 核的机器来说，Redis 官方建议配置 6 个 IO 线程。
 *                      （io-threads  6）
 *
 *
 *          }
 *
 *
 *   }
 *
 *
 *   2 客户端缓存->{
 *
 *      服务端协助的客户端缓存功能，也称为跟踪（Tracking）功能。
 *      有了这个功能，业务应用中的 Redis 客户端就可以把读取的数据缓存在业务应用本地了，应用就可以直接在本地快速读取数据了。
 *
 *      如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理？-》{
 *
 *          1 第一种模式是普通模式。在这个模式下，
 *              实例会在服务端记录客户端读取过的 key，并监测 key 是否有修改。一旦 key 的值发生变化，
 *              服务端会给客户端发送 invalidate 消息，通知客户端缓存失效了。
 *              （我们可以通过执行下面的命令，打开或关闭普通模式下的 Tracking 功能。 ）
 *              CLIENT TRACKING ON|OFF
 *
 *          2 第二种模式是广播模式。在这个模式下，-》{
 *              服务端会给客户端广播所有 key 的失效情况，不过，这样做了之后，如果 key 被频繁修改，
 *              服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。
 *
 *              所以，在实际应用时，我们会让客户端注册希望跟踪的 key 的前缀，当带有注册前缀的 key 被修改时，
 *              服务端会把失效消息广播给所有注册的客户端。和普通模式不同，
 *              在广播模式下，即使客户端还没有读取过 key，但只要它注册了要跟踪的 key，服务端都会把 key 失效消息通知给这个客户端。
 *          }
 *
 *      }
 *
 *
 *   }
 *
 *
 *   3 细粒度的权限控制->{
 *
 *          首先，6.0 版本支持创建不同用户来使用 Redis
 *              在 6.0 版本前，所有客户端可以使用同一个密码进行登录使用，但是没有用户的概念，
 *              而在 6.0 中，我们可以使用 ACL SETUSER 命令创建用户。
 *              例如，我们可以执行下面的命令，创建并启用一个用户 normaluser，把它的密码设置为“abc”：
 *              （ACL SETUSER normaluser on > abc）
 *          另外，6.0 版本还支持以用户为粒度设置命令操作的访问权限。
 *              加号（+）和减号（-）就分别表示给用户赋予或撤销命令的调用权限。
 *
 *              假设我们要设置用户 normaluser 只能调用 Hash 类型的命令操作，而不能调用 String 类型的命令操作，我们可以执行如下命令
 *              （ACL SETUSER normaluser +@hash -@string）
 *
 *
 *
 *
 *   }
 *
 *
 *   4 RESP 3 协议的使用->{
 *          启用 RESP 3 协议
 *
 *              Redis 6.0 实现了 RESP 3 通信协议，而之前都是使用的 RESP 2。
 *              在 RESP 2 中，客户端和服务器端的通信内容都是以字节数组形式进行编码的，
 *              客户端需要根据操作的命令或是数据类型自行对传输的数据进行解码，增加了客户端开发复杂度。
 *
 *
 *   }
 *
 *
 *  </>
 *
 *
 *  <>redis 优化意见
 *
 *      1 键值对使用规范 -》{
 *          1 规范一：key 的命名规范-》{
 *
 *             1 key 的命名规范，只有命名规范，才能提供可读性强、可维护性好的 key，方便日常管理；
 *             2 value 的设计规范，包括避免 bigkey、选择高效序列化方法和压缩方法、使用整数对象共享池、数据类型选择。
 *           }
 *          2规范二：避免使用 bigkey-》{
 *
 *              情况一：键值对的值大小本身就很大，例如 value 为 1MB 的 String 类型数据。为了避免 String 类型的 bigkey，在业务层，我们要尽量把 String 类型的数据大小控制在 10KB 以下。
 *              情况二：键值对的值是集合类型，集合元素个数非常多，例如包含 100 万个元素的 Hash 集合类型数据。为了避免集合类型的 bigkey，我给你的设计规范建议是，尽量把集合类型的元素个数控制在 1 万以下。
 *          }
 *          3 规范三：使用高效序列化方法和压缩方法
 *
 *          4 规范四：使用整数对象共享池
 *
 *
 *      }
 *
 *  2 数据保存规范-》{
 *
 *
 *          规范一：使用 Redis 保存热数据
 *
 *          规范二：不同的业务数据分实例存储
 *
 *          规范三：在数据保存时，要设置过期时间
 *
 *          规范四：控制 Redis 实例的容量
 *
 *
 *  }
 *
 *  3 命令使用规范-》{
 *
 *          规范一：线上禁用部分命令 -{
 *
 *              KEYS，按照键值对的 key 内容进行匹配，返回符合匹配条件的键值对，该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；
 *              FLUSHALL，删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；
 *              FLUSHDB，删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。
 *
 *          }
 *
 *          规范二：慎用 MONITOR 命令
 *
 *          规范三：慎用全量操作命令
 *
 *
 *  }
 *
 *
 *  </>
 *
 *  <>redis 运维
 *
 *          1   最基本的监控命令：INFO 命令-》{
 *
 *
 *                  无论你是运行单实例或是集群，我建议你重点关注一下
 *                  stat：通用统计信息
 *                  commandstat： 不通类型命令的调用统计信息
 *                  cpu 查询cpu情况
 *                  memory 查看内存使用情况
 *
 *
 *          }
 *
 *          2 redis运维的工具-》{
 *
 *              1 面向 Prometheus 的 Redis-exporter 监控
 *              2 数据迁移工具 Redis-shake -》{
 *
 *                  Redis-shake 的基本运行原理，是先启动 Redis-shake 进程，这个进程模拟了一个 Redis 实例。
 *                  然后，Redis-shake 进程和数据迁出的源实例进行数据的全量同步。
 *
 *              }
 *              3 数据一致性比对工具 redis-full-check -》{
 *
 *                  Redis-full-check 提供了三种比对模式，我们可以通过 comparemode 参数进行设置
 *
 *                  1 KeyOutline，只对比 key 值是否相等；
 *                  2 ValueOutline，只对比 value 值的长度是否相等；
 *                  3 FullValue，对比 key 值、value 长度、value 值是否相等。
 *
 *              }
 *              4 集群管理工具 CacheCloud
 *                  实现了主从集群、哨兵集群和 Redis Cluster 的自动部署和管理
 *
 *          }
 *
 *
 *  </>
 *
 * </>
 */
public class RedisDemo {


    String script ="if redis.call(\"get\",KEYS[1]) == ARGV[1]\n" +
            "    then\n" +
            "    return redis.call(\"del\",KEYS[1])\n" +
            "            else\n" +
            "            return 0\n" +
            "    end";

    public static void main(String[] args) {
    		    System.out.println("hello world ");
    }

}

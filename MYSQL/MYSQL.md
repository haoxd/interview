

#### Mysql 隔离级别
 
- 1.读未提交（Read uncommitted）：
   
   这种事务隔离级别下，select语句不加锁。
   
   此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。
   
- 2.读已提交（Read committed）：
   
   可避免 脏读 的发生。
   
   Oracle 的默认隔离级别
   
   
- 3.可重复读（Repeatable read）：
   
   MySql默认隔离级别。
   
   可避免 脏读 、不可重复读 的发生。  在互联网大数据量，高并发量的场景下，几乎 不会使用

   
- 4.串行化（Serializable ）：
   
   可避免 脏读、不可重复读、幻读 的发生。
   
   
- 1.脏读：
  
  脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。

- 2.不可重复读：
  
  不可重复读是指对于数据库中的某一条数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。
  
- 3.幻读
  
  幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，
  这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。
  而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
  
  幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），
  所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

    #### 什么是 MVCC

- 多版本并发控制 （Multi-Version Concurrency Control）

    MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
    MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读
    
- 当前读：

     像select lock in share mode(共享锁),
     select for update ; 
     update, insert ,
     delete(排他锁)这些操作都是一种当前读，为什么叫当前读？
     就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
     
- 快照读：

    像不加锁的select操作就是快照读，即不加锁的非阻塞读；
    快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；
    之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,
    可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，
    即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本
    
    
-  MVCC能解决什么问题
    
    数据库并发场景有三种，分别为：
    
    读-读：不存在任何问题，也不需要并发控制
    
    读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
    
    写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
    
    
- MVCC带来的好处是

  多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 
  所以MVCC可以为数据库解决以下问题
  
  在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
  同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题


- MVCC 实现原理

    1 主要依赖三部分
        
            {
              1 数据库表的三个隐藏字段 
                        
                            {
                                    DB_TRX_ID : 数据库记录最新行数据的事务编号
                                    DB_ROLL_PTR : 回滚指针，上个版本的编码，配合undolog，指向上个旧版本
                                    DB_ROW_ID : 在innodb引擎下，如果表没有设置主键，会自动生成一个6字节的row_id
                                    
                            
                            }
              2 undolog
                    
                    {
                        undolog 是mysql当中的回滚日志，当执行insert，update，delete操作的时候，在undolog当中会记录事务修改的
                            的版本链表，链表的表头存储最新的旧记录，表尾存储最早的旧纪录
                    }
                    
                    
              3 readview
              
              
                    {
                        三个 属性 trx_list(活跃事务列表),up_limit_id（活跃事务列表当中最小的值） ,low_limit_id （尚未分配事务的编号）
                        三个判断规则
                        if（DB_TRX_ID<up_limit_id）{
                            return DB_TRX_ID 的记录
                        }else{
                            if(DB_TRX_ID>=up_limit_id){
                                代表当前的事务是在记录是readview生产后才出现的，肯定看不到当前的版本，看不见其他的事务提交的数据
                            }else{
                                if(DB_TRX_ID in trx_list){
                                    看不到
                                }else{
                                看到
                                }
                            }
                            
                        }
                    
                    }
            
            }
            
     RC隔离级别下，每个快照度都会创建readview
     RR隔离级别下，创建第一个事务的快照读的readview，其他的快照度都使用创建好的readview
      